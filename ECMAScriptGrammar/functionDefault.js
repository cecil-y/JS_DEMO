// 函数默认值

//es5写法：
function func1(a) {
    return a || 1;
}

func1(); // 1
//es6写法：
function func2(a = 1) {
    return a;
}
func2(); //1

//例子：
let w = 1, z = 2;
function func3(x = w + 1, y = x + 1, z = z + 1) {
    console.log(x, y, z);   //Uncaught ReferenceError: z is not defined
}
func3();
// 这里同样没有传参数,使用函数的默认赋值,x通过词法作用域找到了变量w,所以x默认值为2,y同样通过词法作用域找到了刚刚定义的x变量,y的默认值为3,
// 但是在解析到z = z + 1这一行的时候,JS解释器先会去解析z+1找到相应的值后再赋给变量z,但是因为暂时性死区的原因(let/const"劫持"了这个块级作用域,
// 无法在声明之前使用这个变量,上文有解释),导致在let声明之前就使用了变量z,所以会报错


//函数默认值配合解构赋值
function func4({x=10}={},{y}={y:10}){
    console.log(x,y);
}
func4({},{}); // 10,undefined
func4(undefined,{}); // 10,undefined
func4(undefined,undefined); //10,10
func4(); //10,10
func4({x:1},{y:2}); //1,2
// 解析：
// 第一行给func函数传入了2个空对象,所以函数的第一第二个参数都不会使用函数默认值,然后函数的第一个参数会尝试解构对象,提取变量x,
// 因为第一个参数传入了一个空对象,所以解构不出变量x,但是这里又在内层设置了一个默认值,所以x的值为10,而第二个参数同样传了一个空对象,、
// 不会使用函数默认值,然后会尝试解构出变量y,发现空对象中也没有变量y,但是y没有设置默认值所以解构后y的值为undefined
// 第二行第一个参数显式的传入了一个undefined,所以会使用函数默认值为一个空对象,随后和第一行一样尝试解构x发现x为undefined,但是设置了默认值所以x的值为10,而y和上文一样为undefined
// 第三行2个参数都会undefined,第一个参数和上文一样,第二个参数会调用函数默认值,赋值为{y:10},然后尝试解构出变量y,即y为10
// 第四行和第三行相同,一个是显式传入undefined,一个是隐式不传参数
// 第五行直接使用传入的参数,不会使用函数默认值,并且能够顺利的解构出变量x,y
